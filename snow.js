// Generated by CoffeeScript 1.10.0
var slice = [].slice;

$(function() {
  var Flake, FlakeFrag, animate, bgColour, camT, camZ, camZRange, camera, casaLogoMessage, caster, doCamPan, doCamZoom, doubleTapDetect, down, dvp, explodeAll, flake, flakeXpode, flakes, halfPi, i, iOS, k, kvp, l, last, lastTapTime, len, maxSpeedMultiplier, meshMaterial, moved, oneThirdPi, origCamZoom, params, paused, piOver180, randInRange, ref, ref1, ref2, renderer, scene, setSize, snowColour, snowMaterial, speed, startCamPan, startCamZoom, stats, stopCamPan, sx, sy, togglePause, toggleSpeed, twoPi, updateCamPos, v, verticesFromSVGPaths, windChange, windSpeed, windT, wls;
  if (!(window.WebGLRenderingContext && document.createElement('canvas').getContext('experimental-webgl'))) {
    $('#noWebGL').show();
    return;
  }
  casaLogoMessage = '[CASA]';
  params = {
    flakes: 200,
    speed: 1,
    linewidth: 1,
    stats: 0,
    credits: 1,
    inv: 0,
    message: casaLogoMessage
  };
  wls = window.location.search;
  if (wls.length > 0) {
    ref = wls.substring(1).split('&');
    for (l = 0, len = ref.length; l < len; l++) {
      kvp = ref[l];
      ref1 = kvp.split('='), k = ref1[0], v = ref1[1];
      if (k !== 'message') {
        v = parseInt(v);
      }
      params[k] = v;
    }
  } else {
    window.location.replace(window.location.href + '?' + ((function() {
      var results;
      results = [];
      for (k in params) {
        v = params[k];
        results.push(k + "=" + v);
      }
      return results;
    })()).join('&'));
  }
  iOS = navigator.appVersion.match(/iPhone|iPad/);
  snowColour = params.inv ? 0x666666 : 0xffffff;
  bgColour = params.inv ? 0xffffff : 0x000011;
  snowMaterial = new THREE.LineBasicMaterial({
    color: snowColour,
    linewidth: params.linewidth
  });
  meshMaterial = new THREE.MeshBasicMaterial({
    color: 0x888888,
    side: THREE.DoubleSide
  });
  if (iOS) {
    $('#creditInner').html('responds to: <b>swipe</b> — <b>pinch</b> — <b>tap</b> (on snowflake) — <b>double tap</b>');
  }
  if (params.credits) {
    $('#creditOuter').show();
  }
  if (params.stats) {
    stats = new Stats();
    stats.domElement.id = 'stats';
    document.body.appendChild(stats.domElement);
  }
  Transform.prototype.t = Transform.prototype.transformPoint;
  twoPi = Math.PI * 2;
  halfPi = Math.PI / 2;
  oneThirdPi = Math.PI / 3;
  piOver180 = Math.PI / 180;
  v = function(x, y, z) {
    return new THREE.Vector3(x, y, z);
  };
  randInRange = function() {
    var range;
    range = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (typeof range[0] !== 'number') {
      range = range[0];
    }
    return range[0] + Math.random() * (range[1] - range[0]);
  };
  verticesFromSVGPaths = function(svg, t) {
    var c, cmd, d, ds, dummy, len1, m, matches, newV, oldV, origV, re, vertices, x, y;
    if (t == null) {
      t = new Transform();
    }
    ds = [];
    re = /d\s*=\s*("|')([^"']+)("|')/g;
    while ((matches = re.exec(svg)) != null) {
      ds.push(matches[2]);
    }
    vertices = [];
    for (m = 0, len1 = ds.length; m < len1; m++) {
      d = ds[m];
      re = /([M|L])\s+(-?[0-9.]+)\s+(-?[0-9.]+)|Z\s+/g;
      origV = oldV = null;
      while ((matches = re.exec(d)) != null) {
        dummy = matches[0], cmd = matches[1], x = matches[2], y = matches[3];
        c = t.t(x, y);
        newV = v(c[0], c[1], 0);
        if (cmd === 'M') {
          origV = oldV = newV;
        } else {
          if (cmd !== 'L') {
            newV = origV;
          }
          vertices.push(oldV, newV);
          oldV = newV;
        }
      }
    }
    return vertices;
  };
  FlakeFrag = (function() {
    function FlakeFrag(maxLevel, level) {
      var i, maxKids;
      if (level == null) {
        level = 0;
      }
      this.x = level === 0 ? 0 : Math.random();
      this.y = level === 0 ? 0 : Math.random();
      if (level >= maxLevel) {
        return;
      }
      maxKids = level === 0 ? 1 : 3;
      this.kids = (function() {
        var m, ref2, results;
        results = [];
        for (i = m = 0, ref2 = randInRange(1, maxKids); 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
          results.push(new FlakeFrag(maxLevel, level + 1));
        }
        return results;
      })();
    }

    FlakeFrag.prototype.vertices = function(scale, explodeness) {
      var i, j, len1, m, n, ref2, t, vertices;
      if (explodeness == null) {
        explodeness = 0;
      }
      vertices = [];
      t = new Transform();
      t.scale(scale, scale);
      ref2 = [1, -1];
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        j = ref2[m];
        t.scale(1, j);
        for (i = n = 0; n <= 5; i = ++n) {
          t.rotate(oneThirdPi);
          this._vertices(vertices, t, explodeness);
        }
      }
      return vertices;
    };

    FlakeFrag.prototype._vertices = function(vertices, t, explodeness) {
      var c, commonV, kid, len1, m, ref2;
      if (!this.kids) {
        return;
      }
      t.translate(this.x + explodeness, this.y + explodeness);
      c = t.t(0, 0);
      commonV = v(c[0], c[1], 0);
      ref2 = this.kids;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        kid = ref2[m];
        c = t.t(kid.x, kid.y);
        vertices.push(commonV, v(c[0], c[1], 0));
        kid._vertices(vertices, t, explodeness);
      }
      return t.translate(-this.x - explodeness, -this.y - explodeness);
    };

    return FlakeFrag;

  })();
  Flake = (function() {
    var t, text;

    Flake.prototype.xRange = [-150, 150];

    Flake.prototype.yRange = [150, -150];

    Flake.prototype.zRange = [-150, 150];

    Flake.prototype.explodeSpeed = 0.003;

    Flake.prototype.logo = params.message === casaLogoMessage ? (t = new Transform(), t.translate(-16, 22), t.scale(0.5, -0.5), verticesFromSVGPaths(window.logoSvg, t)) : (Spindlytext.prototype.latFactor = 1, text = decodeURIComponent(params.message), verticesFromSVGPaths(new Spindlytext().text(text, {
      lineSpace: 0
    }).svg()));

    function Flake() {
      this.reset();
    }

    Flake.prototype.reset = function(showOrigin) {
      var geom, maxLevel;
      if (showOrigin == null) {
        showOrigin = false;
      }
      if (this.line) {
        scene.remove(this.line);
        this.line.geometry.dispose();
      }
      this.scale = randInRange(3, 6);
      maxLevel = Math.random() < 0.4 ? 3 : 2;
      if (Math.random() < 0.5 / params.flakes) {
        this.rootFrag = null;
        this.size = 40;
      } else {
        this.rootFrag = new FlakeFrag(maxLevel);
        this.size = 0.67 * this.scale * (maxLevel + 1) * 2;
      }
      this.explodingness = this.explodedness = 0;
      geom = new THREE.Geometry();
      geom.dynamic = true;
      geom.vertices = this.rootFrag ? this.rootFrag.vertices(this.scale) : this.logo;
      if (showOrigin) {
        geom.vertices.push(v(-5, 0, 0), v(5, 0, 0), v(0, -5, 0), v(0, 5, 0));
      }
      this.line = new THREE.LineSegments(geom, snowMaterial);
      this.line.rotation.set(randInRange(0, twoPi), randInRange(0, twoPi), randInRange(0, twoPi));
      this.velocity = new THREE.Vector3(randInRange(-0.002, 0.002), randInRange(-0.010, -0.011), randInRange(-0.002, 0.002));
      this.rotality = new THREE.Vector3(randInRange(-0.0003, 0.0003), randInRange(-0.0003, 0.0003), randInRange(-0.0003, 0.0003));
      this.line.position.set(randInRange(this.xRange), this.yRange[0], randInRange(this.zRange));
      return scene.add(this.line);
    };

    Flake.prototype.tick = function(dt, wind) {
      var pos, rly, rot, vel;
      pos = this.line.position;
      vel = this.velocity;
      pos.x += vel.x * dt + wind[0];
      pos.y += vel.y * dt;
      pos.z += vel.z * dt + wind[1];
      rot = this.line.rotation;
      rly = this.rotality;
      rot.set(rot.x + rly.x * dt, rot.y + rly.y * dt, rot.z + rly.z * dt);
      if (this.rootFrag && this.explodingness !== 0) {
        this.explodedness += this.explodingness * this.explodeSpeed * dt;
        this.line.geometry.vertices = this.rootFrag.vertices(this.scale, this.explodedness);
        this.line.geometry.verticesNeedUpdate = true;
      }
      if (pos.y < this.yRange[1]) {
        return this.reset();
      }
    };

    Flake.prototype.click = function(ev) {
      if (this.rootFrag) {
        return this.explodingness = ev.shiftKey ? -1 : 1;
      } else if (params.message === casaLogoMessage && !iOS) {
        return window.open('http://casa.ucl.ac.uk', 'casa');
      }
    };

    return Flake;

  })();
  dvp = (ref2 = window.devicePixelRatio) != null ? ref2 : 1;
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  camera = new THREE.PerspectiveCamera(33, 1, 1, 10000);
  setSize = function() {
    renderer.setSize(window.innerWidth * dvp, window.innerHeight * dvp);
    renderer.domElement.style.width = window.innerWidth + 'px';
    renderer.domElement.style.height = window.innerHeight + 'px';
    camera.aspect = window.innerWidth / window.innerHeight;
    return camera.updateProjectionMatrix();
  };
  setSize();
  document.body.appendChild(renderer.domElement);
  renderer.setClearColor(bgColour, 1);
  renderer.clear();
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(bgColour, 0.0028);
  caster = new THREE.Raycaster();
  flakes = (function() {
    var m, ref3, results;
    results = [];
    for (i = m = 0, ref3 = params.flakes; 0 <= ref3 ? m < ref3 : m > ref3; i = 0 <= ref3 ? ++m : --m) {
      flake = new Flake();
      flake.line.position.y = randInRange(flake.yRange);
      results.push(flake);
    }
    return results;
  })();
  paused = down = moved = false;
  sx = sy = windSpeed = lastTapTime = 0;
  camZRange = [300, 50];
  camZ = camZRange[0];
  last = origCamZoom = null;
  camT = new Transform();
  windT = new Transform();
  windT.rotate(-halfPi);
  speed = params.speed;
  maxSpeedMultiplier = 3;
  updateCamPos = function() {
    var ref3;
    return ref3 = camT.t(0, camZ), camera.position.x = ref3[0], camera.position.z = ref3[1], ref3;
  };
  animate = function(t) {
    var dt, len1, m, wind;
    dt = last != null ? (t - last) * speed : 0;
    if (dt > 1000) {
      dt = 30;
    }
    wind = windT.t(0, windSpeed);
    if (!paused) {
      for (m = 0, len1 = flakes.length; m < len1; m++) {
        flake = flakes[m];
        flake.tick(dt, wind);
      }
    }
    renderer.clear();
    camera.lookAt(scene.position);
    renderer.render(scene, camera);
    last = t;
    window.requestAnimationFrame(animate, renderer.domElement);
    if (params.stats) {
      return stats.update();
    }
  };
  updateCamPos();
  window.requestAnimationFrame(animate, renderer.domElement);
  $(window).on('resize', setSize);
  toggleSpeed = function() {
    return speed = speed === params.speed ? params.speed * maxSpeedMultiplier : params.speed;
  };
  togglePause = function() {
    return paused = !paused;
  };
  explodeAll = function(ev) {
    var len1, m, results;
    results = [];
    for (m = 0, len1 = flakes.length; m < len1; m++) {
      flake = flakes[m];
      results.push(flake.rootFrag ? flake.click(ev) : void 0);
    }
    return results;
  };
  $(document).on('keyup', function(ev) {
    var ref3;
    if ((ref3 = ev.keyCode) !== 32 && ref3 !== 80 && ref3 !== 27) {
      return;
    }
    ev.preventDefault();
    switch (ev.keyCode) {
      case 32:
        return toggleSpeed();
      case 80:
        return togglePause();
      case 27:
        return explodeAll(ev);
    }
  });
  flakeXpode = function(ev) {
    var eventX, eventY, intersects, len1, m, mesh, meshes, results, vector;
    if (moved > 3) {
      return;
    }
    eventX = ev.clientX || ev.originalEvent.touches[0].clientX;
    eventY = ev.clientY || ev.originalEvent.touches[0].clientY;
    meshes = (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = flakes.length; m < len1; m++) {
        flake = flakes[m];
        mesh = new THREE.Mesh(new THREE.PlaneGeometry(flake.size, flake.size), meshMaterial);
        mesh.position.copy(flake.line.position);
        mesh.rotation = flake.line.rotation;
        mesh.flake = flake;
        scene.add(mesh);
        results.push(mesh);
      }
      return results;
    })();
    scene.updateMatrixWorld();
    vector = new THREE.Vector2((eventX / window.innerWidth) * 2 - 1, -(eventY / window.innerHeight) * 2 + 1);
    caster.setFromCamera(vector, camera);
    intersects = caster.intersectObjects(meshes);
    if (intersects.length > 0) {
      flake = intersects[0].object.flake;
      flake.click(ev);
    }
    results = [];
    for (m = 0, len1 = meshes.length; m < len1; m++) {
      mesh = meshes[m];
      scene.remove(mesh);
      results.push(mesh.geometry.dispose());
    }
    return results;
  };
  $(renderer.domElement).on('click touchend', flakeXpode);
  doubleTapDetect = function(ev) {
    var now, tapGap;
    now = new Date().getTime();
    tapGap = now - lastTapTime;
    if (tapGap < 250 && ev.originalEvent.touches.length < 2) {
      toggleSpeed();
    }
    return lastTapTime = now;
  };
  $(renderer.domElement).on('touchstart', doubleTapDetect);
  windChange = function(ev) {
    return windSpeed = (ev.clientX / window.innerWidth - 0.5) * 0.15;
  };
  $(renderer.domElement).on('mousemove', windChange);
  startCamPan = function(ev) {
    if (ev.originalEvent.touches && ev.originalEvent.touches.length !== 1) {
      stopCamPan();
      return;
    }
    down = true;
    moved = 0;
    sx = ev.clientX || ev.originalEvent.touches[0].clientX;
    return sy = ev.clientY || ev.originalEvent.touches[0].clientY;
  };
  $(renderer.domElement).on('mousedown touchstart touchend touchcancel', startCamPan);
  stopCamPan = function() {
    return down = false;
  };
  $(renderer.domElement).on('mouseup', stopCamPan);
  doCamPan = function(ev) {
    var dx, dy, rotation;
    if (down) {
      moved += 1;
      dx = (ev.clientX || ev.originalEvent.touches[0].clientX) - sx;
      dy = (ev.clientY || ev.originalEvent.touches[0].clientY) - sy;
      rotation = dx * -0.0005 * Math.log(camZ);
      camT.rotate(rotation);
      windT.rotate(rotation);
      updateCamPos();
      sx += dx;
      return sy += dy;
    }
  };
  $(renderer.domElement).on('mousemove touchmove', doCamPan);
  doCamZoom = function(ev, d, dX, dY) {
    var newCamZoom;
    if (dY != null) {
      camZ -= dY * 5;
    } else {
      newCamZoom = origCamZoom + Math.log(ev.originalEvent.scale);
      camZ = (1 - newCamZoom) * (camZRange[0] - camZRange[1]) + camZRange[1];
    }
    camZ = Math.max(camZ, camZRange[1]);
    camZ = Math.min(camZ, camZRange[0]);
    return updateCamPos();
  };
  $(renderer.domElement).on('mousewheel gesturechange', doCamZoom);
  startCamZoom = function(ev) {
    origCamZoom = 1 - (camZ - camZRange[1]) / (camZRange[0] - camZRange[1]);
    return moved = 100;
  };
  return $(renderer.domElement).on('gesturestart', startCamZoom);
});

//# sourceMappingURL=snow.js.map
